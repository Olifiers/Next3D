C:/Users/Flash/AppData/Local/Temp/zcc0000BC1053E82.asm:
     1                          MODULE main_asm
     2                          LINE 0, "main.asm"
main.asm:
                                
     1                          INCLUDE "globals.inc"
globals.inc:
     1                          
     2                          START_16K_BANK = 9
     3                          START_8K_BANK = 18  ; START_16K_BANK*2
     4                          
     5                          MMU_REGISTER_0 = 0x50
     6                          MMU_REGISTER_1 = 0x51
     7                          MMU_REGISTER_2 = 0x52
     8                          MMU_REGISTER_3 = 0x53
     9                          MMU_REGISTER_4 = 0x54
    10                          MMU_REGISTER_5 = 0x55
    11                          MMU_REGISTER_6 = 0x56
    12                          MMU_REGISTER_7 = 0x57
    13                          
main.asm:
     2                          
     3                          SECTION code_user    ;; put in main binary
     4  0000  00                EXTERN  _x1:        db  0
     5  0001  00                EXTERN  _y1:        db  0
     6  0002  00                EXTERN  _x2:        db  0
     7  0003  00                EXTERN  _y2:        db  0
     8  0004  00                EXTERN  _colour:    db  0
     9                          
    10                          ; ===========================================================================================
    11                              ; Perenial definitions for trigFillL2 (routine to draw filled triangles)
    12                              ; Triangle line p0-p2
    13  0005  00                    Tri_ac_r0: defs 1   ; x
    14  0006  00                    Tri_ac_r1: defs 1   ; Width/deltax
    15  0007  00                    Tri_ac_r2: defs 1   ; Height/deltay
    16  0008  00                    Tri_ac_r3: defs 1   ; Error Bresenhams
    17  0009  00                    Tri_ac_r4: defs 1   ; Quadrant... Direction... Bit? 0 or 1 -- Flags
    18                              ; Triangle line p0-p1
    19  000a  00                    Tri_ab_r0: defs 1   ; x
    20  000b  00                    Tri_ab_r1: defs 1   ; Width/deltax
    21  000c  00                    Tri_ab_r2: defs 1   ; Height/deltay
    22  000d  00                    Tri_ab_r3: defs 1   ; Error Bresenhams
    23  000e  00                    Tri_ab_r4: defs 1   ; Quadrant... Direction... Bit? 0 or 1 -- Flags
    24                              ; Triangle point coordinates
    25  000f  0000                  p0: defs 2          ; p0.y and p0.x
    26  0011  0000                  p1: defs 2          ; p1.y and p1.x
    27  0013  0000                  p2: defs 2          ; p2.y and p2.x
    28                          ; ix: 5 bytes required per line
    29                          ; +00: x
    30                          ; +01: deltax
    31                          ; +02: deltay
    32                          ; +03: Bresenhams error
    33                          ; +04: Flags / Quadrant
    34                              XCoord: = 0
    35                              DeltaX: = 1
    36                              DeltaY: = 2
    37                              Error: = 3
    38                              Flags: = 4
    39                          ; extern void stop(void)
    40                          ; A debugging tool. Jump here (jp _stop) from your code so you can stop and inspect registers etc.
    41                          ; ============================================================================================
    42                          PUBLIC _stop
    43                          _stop:
    44                          
    45  0015  c31500                jp _stop
    46                          
    47                          
    48                          ; extern void setCPU(void)
    49                          ; Sets the Next CPU to maximum speed, 28MHz
    50                          ; ===========================================================================================
    51                          PUBLIC _setCPU
    52                          _setCPU:
    53                          
    54                              ;;NEXTREG 03h,%00110011 ; Set machine to Spectrum Next
    55  0018  ed910700              NEXTREG 07h,0           ; Set CPU to 28MHz (CURRENTLY SET TO 0 FOR DEBUG!!!)
    56  001c  c9                    RET
    57                          
    58                          
    59                          ; void initL2(void)
    60                          ; Initialises the Layer 2 Next screen mode into 256x192 256 colours in front of the ULA screen
    61                          ; ============================================================================================
    62                          PUBLIC _initL2
    63                          _initL2:
    64                          
    65                              ; Enable Layer 2
    66  001d  013b12                LD BC, 0x123B
    67  0020  3e02                  LD A, 2
    68  0022  ed79                  OUT (C), A
    69                          
    70                              ; Setup starting Layer2 16K bank
    71  0024  ed911209              NEXTREG 12h, 9
    72  0028  c9                    RET
    73                          
    74                          
    75                          ; void clearL2(unsigned char colour) __z88dk_fastcall
    76                          ; param is in L if it's 8-bit, HL if it's 16-bit, DEHL if it's 32-bit.
    77                          ; A terrible screen cleaning routine we'll have to optmise the hell out of soon!
    78                          ; =============================================================================================
    79                          PUBLIC _clearL2
    80                          _clearL2:
    81                          
    82  0029  1600                  LD D, 0             ; D=Y, start at top of the screen
    83                          
    84                          nextY:
    85                              ;Calculate bank number and swap it in
    86  002b  7a                    LD A, D             ; Copy current Y to A
    87  002c  e6e0                  AND %11100000       ; 32100000 (3MSB = bank number)
    88  002e  07                    RLCA                ; 21000003
    89  002f  07                    RLCA                ; 10000032
    90  0030  07                    RLCA                ; 00000321
    91  0031  c612                  ADD A, START_8K_BANK    ; A=bank number to swap in
    92  0033  ed9256                NEXTREG 56h, A      ; Swap bank
    93                          
    94                              ; Convert DE (yx) to screen memory location starting at $C000
    95  0036  d5                    PUSH DE             ; (DE) will be changed to bank offset
    96  0037  7a                    LD A, D             ; Copy current Y to A
    97  0038  e61f                  AND %00011111       ; Discard bank number
    98  003a  f6c0                  OR 0xC0             ; Screen starts at $C000
    99  003c  57                    LD D, A             ; D=high byte for $C000 screen memory
   100                          
   101                              ; Loop X through 0..255, we dont have to deal with bank swapping
   102                              ; here because it only occurs when changing Y
   103  003d  1e00                  LD E, 0             ; X=0 (X is E, Y is D)
   104                          
   105                          nextX:
   106  003f  7d                    LD A, L             ; A=current X
   107  0040  12                    LD (DE), A          ; Use L as colour. Variable is passed via DEHL - L if its 8-bit, HL if its 16-bit, DEHL if its 32-bit.
   108  0041  7b                    LD A, E             ; A=current X
   109  0042  1c                    INC E               ; Increment to next X
   110  0043  20fa                  JR NZ, nextX        ; Loop to nextX until E rolls over
   111                          
   112                              ; Continue with next line or exit
   113  0045  d1                    POP DE              ; Restore DE to coordinates
   114  0046  14                    INC D               ; Increment to next Y
   115  0047  7a                    LD A, D             ; A=current Y
   116  0048  fec0                  CP 192              ; Did we just complete last line?
   117  004a  da2b00                JP C, nextY         ; No, continue with next line
   118  004d  c9                    RET
   119                          
   120                          
   121                          ; extern void PlotPixel8K(uint8_t xcoord, uint8_t ycoord, uint8_t colour) __z88dk_callee
   122                          ; Generic plotting routine that can be called from C
   123                          ; ========================================================================================
   124                          PUBLIC _PlotPixel8K, PlotPixel8K
   125                          _PlotPixel8K:
   126                          
   127                              ;jp _PlotPixel8K
   128  004e  e1                   	pop hl          ; Loads the stack value (sp) into hl for restoring later and moves variables into top of stack
   129  004f  d1                   	pop de          ; Loads next stack entry into e = x, d = y
   130  0050  3b                   	dec sp          ; Moves the stack up 1 byte, discarding a value and getting us to the third param, colour
   131  0051  e3                   	ex (sp), hl     ; Restores the original value of the stack from hl, and puts the colour on h from the stack
   132  0052  eb                   	ex de, hl       ; Put y and x into hl and the colour into d
   133  0053  fd6a                  ld iyl, d       ; Puts colour into iyl in order to free d for the drawline
   134                          
   135                          
   136                          PlotPixel8K:
   137                          ;===========================================================================
   138                          ;	HL = YX, IYL = colour -- IMPORTANT: DESTROYS H (and A)
   139                          ;===========================================================================
   140                          
   141  0055  7c                	ld a, h 				    ; 0-31 per bank (8k)
   142  0056  e6e0              	and %11100000			    ; 3 bits for the 8 banks we can use
   143  0058  ed23              	swapnib
   144  005a  0f                	rrca
   145  005b  c612              	add a, START_8K_BANK		; 8L bank for L2
   146  005d  ed9250            	nextreg MMU_REGISTER_0,a  	; Set bank to write into
   147  0060  7c                	ld a, h
   148  0061  e61f              	and %00011111 		        ; This is our y (0-31)
   149  0063  67                	ld h, a 				    ; Puts y it back in h
   150  0064  fd7d                  ld a, iyl                   ; Loads colour from iyl into a
   151  0066  77                	ld (hl), a			        ; Draw our pixel
   152                              ; TEMP: SLOW DOWN FOR DEBUG
   153  0067  3eff                  ld a, 255
   154                              ;ld e, 255
   155                          loopy:
   156  0069  00                    nop
   157  006a  00                    nop
   158  006b  00                    nop
   159  006c  00                    nop
   160  006d  00                    nop
   161                              ;dec e
   162                              ;jr nz, loopy
   163  006e  3d                    dec a
   164  006f  20f8                  jr nz, loopy
   165  0071  c9                	ret
   166                          
   167                          
   168                          PlotPixel8KCol:
   169                          ;===========================================================================
   170                          ; This has no C calls and must be called from assembly!!!
   171                          ;
   172                          ;	HL = YX -- IMPORTANT: DESTROYS H (and A)
   173                          ; We preset the colour so we can use it directly
   174                          ; by setting plotPixel8KColour with self-modifying code
   175                          ;===========================================================================
   176                          
   177  0072  7c                	ld a, h 				    ; 0-31 per bank (8k)
   178  0073  e6e0              	and %11100000			    ; 3 bits for the 8 banks we can use
   179  0075  ed23              	swapnib
   180  0077  0f                	rrca
   181  0078  c612              	add a, START_8K_BANK		; 8L bank for L2
   182  007a  ed9250            	nextreg MMU_REGISTER_0,a  	; Set bank to write into
   183  007d  7c                	ld a, h
   184  007e  e61f              	and %00011111 		        ; This is our y (0-31)
   185  0080  67                	ld h, a 				    ; Puts y it back in h
   186                          plotPixel8KColour:
   187  0081  3600                  ld (hl), 0			        ; Draw our pixel (colour is going to be set by automodifying the code)
   188  0083  c9                	ret
   189                          
   190                          
   191                          ; extern void drawL2(uint8_t x1coord, uint8_t y1coord, uint8_t x2coord, uint8_t y2coord, uint8_t colour) __z88dk_callee
   192                          ; A Bresenham's line drawing catering for every type of line and direction, inspired by a bunch of Speccy algos online
   193                          ; ====================================================================================================================
   194                          ; Credits to Andy Dansby (https://github.com/andydansby/bresenham_torture_test/blob/main/bresenham_line3.asm)
   195                          ; Credits to Dean Belfield (http://www.breakintoprogram.co.uk)
   196                          ; Credits to Gabrield Gambetta's great book 'Computer Graphics From Scratch'
   197                          ; Credits to Mike Flash Ware for helping optimise it!
   198                          PUBLIC _drawL2, drawL2
   199                          _drawL2:
   200                          
   201                          ; or, even better, set the colour in AF, and store that in the PlotPixel8KCol
   202  0084  c1                    pop bc          ; Loads the stack value (sp) into bc for restoring later and moves variables into top of stack
   203  0085  e1                    pop hl          ; Loads y1x1 into hl
   204  0086  d1                    pop de          ; Loads y2x2 into de
   205  0087  fde1                  pop iy          ; Use iyl for the colour
   206  0089  c5                    push bc         ; Restores the stack value from bc
   207                          
   208                          drawL2:
   209                          ;=========================================================================
   210                          ;   HL = Y1X1, DE = Y2X2, IYL = colour
   211                          ;=========================================================================
   212  008a  fd7d                  ld a, iyl           ; Loads colour into a
   213  008c  328200                ld (plotPixel8KColour + 1), a ; Store the colour in the plotPixel8KColour through self-modifying the code
   214  008f  7a                    ld a, d             ; Loads y2 into a. We'll see if we need to swap coords to draw downwards
   215  0090  bc                    cp h                ; Compares y1 with y2
   216  0091  3001                  jr nc, draw_line_1  ; No need to swap the coords, jump
   217  0093  eb                    ex de, hl           ; Swapped coordinates to ensure y2 > y1, so we draw downwards
   218                          draw_line_1:
   219  0094  7a                    ld a, d             ; Loads y2 into a
   220  0095  94                    sub h               ; y2 - y1
   221  0096  47                    ld b, a             ; b becomes deltay
   222  0097  7b                    ld a, e             ; Loads x2 into a
   223  0098  95                    sub l               ; x2 - x1, a now contains deltax
   224  0099  3805                  jr c, draw_line_x1  ; If carry is set (x2 - x1 is negative) we are drawing right to left
   225  009b  4f                    ld c, a             ; c becomes deltax
   226  009c  3e2c                  ld a, 0x2C          ; Replaces original code above to increase x1 as we're drawing left to right. 0x2C is inc l, and we modify the code to have this
   227  009e  1805                  jr draw_line_x2     ; Skips next part of the code
   228                          draw_line_x1:
   229  00a0  ed44                  neg                 ; deltax in a is negative, make it positive
   230  00a2  4f                    ld c, a             ; c becomes deltax
   231  00a3  3e2d                  ld a, 0x2D          ; Replaces original code above to decrease x1 as we're drawing right to left. Self-modifying, puts dec l into the code
   232                          draw_line_x2:
   233  00a5  32cb00                ld (draw_line_q1_m2), a ; a contains either inc l or dec l, and modifies the code accordingly
   234  00a8  32e200                ld (draw_line_q2_m2), a ; Same as above for verticalish lines
   235  00ab  78                    ld a, b             ; We'll check if deltay (b) and deltax (ixl) are 0
   236  00ac  b1                    or c                ; Checking...
   237  00ad  ca7200                jp z, PlotPixel8KCol    ; When reaching zero, we're done, draw last pixel
   238                              ; STATUS: b = deltay | c = deltax | d is free
   239                          draw_line_q:            ; Find out what kind of diagonal we're dealing with, if horizontalish or verticalish
   240  00b0  78                    ld a, b             ; Loads deltay into a
   241  00b1  b9                    cp c                ; Compares with deltax
   242  00b2  301d                  jr nc, draw_line_q2 ; If no cary, line is verticalish (or perfectly diagonal)
   243                          draw_line_q1:
   244  00b4  79                    ld a, c             ; a becomes deltax
   245  00b5  32c800                ld (draw_line_q1_m1 + 1), a ; Self-modifying code: loads deltax onto the value of the opcode, in this case the loop
   246  00b8  48                    ld c, b             ; c becomes deltay
   247  00b9  47                    ld b, a             ; b becomes deltax for the loop counter
   248  00ba  58                    ld e, b             ; e becomes deltax temporarily...
   249  00bb  cb3b                  srl e               ; now e = deltax / 2 -- aka Bresenham's error
   250                          ; loop uses d as temp, hl bc e
   251                          draw_line_q1_l:
   252  00bd  54                    ld d, h             ; OPTIMISE? Backs up h into d
   253  00be  cd7200                call PlotPixel8KCol ; PlotPixel8KCol destroys h, so we need to preserve it
   254  00c1  62                    ld h, d             ; OPTIMISE? Restores h from d
   255  00c2  7b                    ld a, e             ; Loads Bresenham's error into a
   256  00c3  91                    sub c               ; error - deltay
   257  00c4  5f                    ld e, a             ; Stores new error value into e
   258  00c5  3004                  jr nc, draw_line_q1_m2  ; If there's no cary, jump
   259                          draw_line_q1_m1:
   260  00c7  c600                  add a, 0            ; This 0 here will be modified by the self-modifying code above e = e + deltax
   261  00c9  5f                    ld e, a             ; Stores new error e = e + deltax back into e
   262  00ca  24                    inc h               ; Increases line slope by adding to y1
   263                          draw_line_q1_m2:        ; This either increases or decreases l by the self modified code that targeted this
   264  00cb  2c                    inc l               ; Self-modified code: It will be either inc l or dec l depending on direction of horizontal drawing
   265                          draw_line_q1_s:         ; Tests to loop and keep drawing line
   266  00cc  10ef                  djnz draw_line_q1_l ; Loops until line is drawn and zero flag set
   267  00ce  c37200                jp PlotPixel8KCol   ; This is the last pixel, draws and quits
   268                          draw_line_q2:           ; Here the line is verticalish or perfectly diagonal
   269  00d1  32e100                ld (draw_line_q2_m1 + 1), a ; Self-modifies the code to store deltay in the loop
   270  00d4  58                    ld e, b             ; e = deltay
   271  00d5  cb3b                  srl e               ; e = deltay / 2 (Bressenham's error)
   272                          ; loop uses d as temp, hl bc e
   273                          draw_line_q2_l:         ; The main drawline loop for this case
   274  00d7  54                    ld d, h             ; OPTIMISE? Backs up h into d
   275  00d8  cd7200                call PlotPixel8KCol ; PlotPixel8KCol destroys h, so we need to preserve it
   276  00db  62                    ld h, d             ; OPTIMISE? Restores h from d
   277  00dc  7b                    ld a, e             ; Adds deltax to the error
   278  00dd  91                    sub c               ; As above
   279  00de  3003                  jr nc, draw_line_q2_s   ; If we don't get a carry, skip the next part
   280                          draw_line_q2_m1:
   281  00e0  c600                  add a, 0            ; This is a target of self-modified code: e = e + deltax
   282                          draw_line_q2_m2:
   283  00e2  2c                    inc l               ; Self-modified code: It will be either inc l or dec l depending on direction of horizontal drawing
   284                          draw_line_q2_s:
   285  00e3  5f                    ld e, a             ; Restores the error value back in
   286  00e4  24                    inc h               ; Increases y1
   287  00e5  10f0                  djnz draw_line_q2_l ; While zero flag not set, loop back to main loop
   288  00e7  c37200                jp PlotPixel8KCol   ; This is the last pixel drawn, all done
   289                          
   290                          
   291                          ;extern void trigL2(Point pt0, Point pt1, Point pt2, uint8_t colour) __z88dk_callee;
   292                          ; A triangle wireframe drawing routine, highly optimised (I hope!)
   293                          ;=================================================================================================
   294                          PUBLIC _trigL2, trigL2
   295                          _trigL2:
   296  00ea  fde1                  pop iy              ; Pops sp into iy
   297  00ec  e1                    pop hl              ; Pops p0.y and p0.x into hl
   298                              ;ld (l1 + 1), hl     ; Self-modifying code, loads hl into l1: hl (l1 start)
   299  00ed  221301                ld (l3 + 4), hl     ; Self-modifying code, loads hl into l3: de (l3 end)
   300  00f0  d1                    pop de              ; Pops p1.y and p1.x into de
   301                              ;ld (l1 + 4), de     ; Self-modifying code, loads de into l1: de (l1 end)
   302  00f1  ed530701              ld (l2 + 1), de     ; Self-modifying code, loads de into l2: hl (l2 start)
   303  00f5  c1                    pop bc              ; Pops p2.y and p2.x into bc
   304  00f6  ed430a01              ld (l2 + 4), bc     ; Self-modifying code, loads bc into l2: de (l2 end)
   305  00fa  ed431001              ld (l3 + 1), bc     ; Self-modifying code, loads cd into l3: hl (l3 start)
   306  00fe  c1                    pop bc              ; Pops colour value into c
   307  00ff  fde5                  push iy             ; Restore stack
   308  0101  fd69                  ld iyl, c           ; Loads colour into iyl
   309                          
   310                          trigL2:
   311                          l1:                     ; Line 1
   312  0103  cd8a00                call drawL2         ; Because hl and de are already set correctly, just draw it
   313                          l2:                     ; Line 2
   314  0106  210000                ld hl, 0            ; Self-modified target from above
   315  0109  110000                ld de, 0            ; Seld-modified target from above
   316  010c  cd8a00                call drawL2         ; Draws line with the modified hl and de with the self-modifying code
   317                          l3:                     ; Line 3
   318  010f  210000                ld hl, 0            ; Self-modified target from above
   319  0112  110000                ld de, 0            ; Self-modified target from above
   320  0115  c38a00                jp drawL2           ; Draws line with the modified hl and de with the self-modifying code
   321  0118  c9                    ret                 ; We're done, return nicely
   322                          
   323                          
   324                          ;extern void fillTrigL2(Point pt0, Point pt1, Point pt2, uint8_t colour) __z88dk_callee;
   325                          ; A filled triangle drawing routine
   326                          ;=================================================================================================
   327                          PUBLIC _fillTrigL2, fillTrigL2
   328                          _fillTrigL2:
   329                              ;p0: Variable (mem address) to store p0
   330                              ;p1: Variable (mem address) to store p1
   331                              ;p2: Variable (mem address) to store p2
   332                              ; End of definitions
   333  0119  fde1                  pop iy              ; Pops sp into iy
   334  011b  e1                    pop hl              ; Pops p0.y and p0.x into hl
   335  011c  d1                    pop de              ; Pops p1.y and p1.x into de
   336  011d  7a                    ld a, d             ; Loads p1.y into a
   337  011e  bc                    cp h                ; Compares p1.y with p0.y
   338  011f  3001                  jr nc, _seq1        ; If p1.y > p0.y, no need to swap, jump
   339  0121  eb                    ex de, hl           ; Swap p0 and p1, de now has the largest y of the two
   340                              ;jp _stop
   341                          _seq1:                  ; Here we have p0.y < p1.y | h < d, now we need to check p2
   342  0122  c1                    pop bc              ; Pops p2.y and p2.x into bc
   343  0123  78                    ld a, b             ; Loads p2.y into a
   344  0124  ba                    cp d                ; Compares p2.y with p1.y
   345  0125  3009                  jr nc, _seq2        ; If p2.y > p1.y, and here we already have p1.y > p0.y, we are done and jump out
   346  0127  c5                    push bc             ; If p2.y < p1.y we need to swap p2 with p1, so we push p2 into stack
   347  0128  d5                    push de             ; Push p1 into stack
   348  0129  c1                    pop bc              ; Pop p1 into bc, becoming the new p2 > p1 on y
   349  012a  d1                    pop de              ; Pop p2 into de, becoming the new p1 < p2 on y
   350  012b  7a                    ld a, d             ; Lastly, we need to compare the new p1 < p0, if not swap them
   351  012c  bc                    cp h                ; Compares the new p1.y with p0.y
   352  012d  3001                  jr nc, _seq2        ; If p1.y > p0.y, no need to swap, jump
   353  012f  eb                    ex de, hl           ; Swap p0 and p1. Now we have p0 < p1 < p2 on the y axis (lh < de < bc)
   354                              ;jp _stop          ; DEBUG: All good here: hl 3C5A | de 7896 | bc B464 -- the correct testing coords ******
   355                          _seq2:
   356  0130  220f00                ld (p0), hl         ; Stores p0
   357  0133  ed531100              ld (p1), de         ; Stores p1
   358  0137  ed431300              ld (p2), bc         ; Stores p2
   359  013b  c1                    pop bc              ; Pops colour value into c
   360  013c  fde5                  push iy             ; Restores stack
   361  013e  fd69                  ld iyl, c           ; Loads colour into iyl
   362                              ;jp _stop           ; DEBUG: All good here
   363                          
   364                          fillTrigL2:
   365  0140  dd210500              ld ix, Tri_ac_r0    ; Sets ix with the address of the first var of the p0-p2 line, so we can access other params sequentially from it
   366  0144  cdd901                call pri_tri_p0p2   ; Calls the set up of the long side of the triangle between p0 and p2
   367  0147  dd210a00              ld ix, Tri_ab_r0    ; Sets ix with the address of the first var of the p0-p1 line, so we can access other params sequentially from it
   368  014b  cdc101                call pri_tri_p0p1   ; Calls the set up of the upper short side of the triangle between p0 and p1
   369  014e  cd0b02                call pri_tri_lc     ; Calls the triangle loop counter
   370  0151  2a0f00                ld hl, (p0)         ; Loads p0.y onto h
   371                              ;jp _stop
   372  0154  cd6301                call draw_triangle  ; call 1f... Find out WHAT THE HELL IS IN ADDRESS 1F OF THIS CODE. WHAT A WAY OF DOING THIS...
   373  0157  e5                    push hl             ; Stores hl on the stack
   374  0158  dd210a00              ld ix, Tri_ab_r0    ; Sets ix with the address of the first var of the p0-p1 line, so we can access other params sequentially from it
   375  015c  cdcd01                call pri_tri_p1p2   ; Calls the set up of the lower short side of the triangle between p1 and p2
   376  015f  cd0b02                call pri_tri_lc     ; Calls the triangle loop counter
   377  0162  e1                    pop hl              ; Restores hl from stack
   378                          
   379                          draw_triangle:
   380  0163  78                    ld a, b             ; We'll check if the triangle height is zero, first we load the loop counter here from pri_tri_l
   381  0164  b7                    or a
   382  0165  c8                    ret z               ; If it's zero, we are done, return
   383                          
   384  0166  c5                    push bc             ; Stack the loop counter - important because pri_tri_b destroys b (our counter)
   385  0167  e5                    push hl             ; Stacks y
   386  0168  dd210500              ld ix, Tri_ac_r0    ; Switches to p0-p2 line
   387                              ;jp _stop            ; DEBUG: ALL SEEMS IN ORDER UP TO HERE
   388  016c  cd8901                call pri_tri_b      ; Advances the long p0-p2 line to its next pixel
   389  016f  dd210a00              ld ix, Tri_ab_r0    ; Switches to p0-p1 line
   390  0173  cd8901                call pri_tri_b      ; Advances the short p0-p1 line to its next pixel
   391                              ;jp _stop            ; DEBUG: SEEMS OK UP TO HERE
   392  0176  e1                    pop hl              ; Brings hl back from stack
   393  0177  e5                    push hl             ; Stacks hl again, but hl remains restored
   394  0178  ed4b0500              ld bc, (Tri_ac_r0)  ; Loads the first point of the horizontal line
   395  017c  ed5b0a00              ld de, (Tri_ab_r0)  ; Loads the second point of the horizontal line
   396                          
   397                          ;    call pri_line_hor   ; Draws the line between the two points, filling this step of the triangle
   398  0180  cd1902                call pri_line_hor_quick   ; Draws the line between the two points, filling this step of the triangle, only sets bank at start
   399  0183  e1                    pop hl              ; Restores hl
   400  0184  24                    inc h               ; Increments y *** ORIGINAL CODE IS HL, BUT I THINK IT WANTS TO INCREMENT Y ***
   401  0185  c1                    pop bc              ; Restores loop counter and y index
   402  0186  05                    dec b               ; Decreases loop / y index *** THIS SURELY WONT WORK AND DOESN'T NEED TO BE 16bits - ORIGINALLY BC, CHANGED TO B
   403  0187  18da                  jr draw_triangle    ; Loops back to top
   404                          
   405                          pri_tri_b:              ; Bresenhams calculations go here
   406  0189  dd6603                ld h, (ix + Error)      ; Loads Bresenhams error into h, works for both lines depending on where ix is pointing to (Tri_ac_r0 or Tri_ab_r0)
   407  018c  dd4601                ld b, (ix + DeltaX)      ; Loads deltax into b
   408  018f  dd5602                ld d, (ix + DeltaY)      ; Loads deltay into d
   409  0192  ddcb044e              bit 1, (ix + Flags)     ; Checks quadrant of line but comparing with the bit on the flag store
   410  0196  280e                  jr z, pri_tri_b_seq2; If zero, skip piece of code below
   411  0198  7c                    ld a, h             ; Loads error into a
   412  0199  92                    sub d               ; error = error - deltay
   413  019a  67                    ld h, a             ; Puts error back in h after operation above
   414  019b  3005                  jr nc, pri_tri_b_seq1; If no carry, skip code below, otherwise continues - DEBUG: 3C-0A, NOT ZERO, JUMPS
   415  019d  80                    add b               ; error = error + deltax
   416  019e  67                    ld h, a             ; Stores error back on h
   417  019f  cdb301                call pri_tri_x      ; Moves the x coordinate ***CHECK THIS!!!***
   418                          pri_tri_b_seq1:         ; Jumps to store the error if no carry, skipping the error + deltax step
   419  01a2  dd7403                ld (ix + Error), h      ; Stores the error into its place for this specific line
   420  01a5  c9                    ret                 ; We're done here and return
   421                          
   422                          
   423                          pri_tri_b_seq2:
   424  01a6  cdb301                call pri_tri_x      ; Moves the x coordinate of the line left or right depending on case
   425  01a9  7c                    ld a, h             ; Loads error into a
   426  01aa  92                    sub d               ; Subtracts deltay (error = error - deltay)
   427  01ab  67                    ld h,a
   428  01ac  30f8                  jr nc, pri_tri_b_seq2; If no carry, loops right back up to work on error again until carry set
   429  01ae  80                    add a,b               ; Carry was set, we now add deltax (error = error + deltax)
   430  01af  dd7703                ld (ix + Error), a      ; Stores the error into its place for this specific line
   431  01b2  c9                    ret                 ; We're done here and return
   432                          
   433                          pri_tri_x:              ; Moves x coord 1 pixel left or right depending on the line type
   434  01b3  ddcb0446              bit 0, (ix + Flags)     ; Sets the direction we're headed towards with x, left or right
   435  01b7  2004                  jr nz, pri_tri_x_seq1; If not zero, we're going left, not right, so decrease
   436  01b9  dd3400                inc (ix + XCoord)        ; Increases line's x
   437  01bc  c9                    ret                 ; *** SIMPLIFIED CODE FROM 16bit, THERE WAS MORE TO IT ORIGINALLY, COULD BREAK
   438                          pri_tri_x_seq1:
   439  01bd  dd3500                dec (ix + XCoord)        ; Decreases line's x
   440  01c0  c9                    ret                 ; *** SIMPLIFIED CODE FROM 16bit, THERE WAS MORE TO IT ORIGINALLY, COULD_BREAK
   441                          
   442                          ; Initialises a block of variables for a line
   443                          ; ix points at the start of the block
   444                          ; b points to line start coordinates in p
   445                          ; c points to line end coordinates in p'
   446                          ; ix: 5 bytes required per line
   447                          ; +00: x
   448                          ; +01: deltax
   449                          ; +02: deltay
   450                          ; +03: Bresenhams error
   451                          ; +04: Flags / Quadrant
   452                          pri_tri_p0p1:           ; Initialises the line p0-p1 *** THIS IS HEAVILLY 16bits, NEEDS CAREFUL REVIEW TO SEE IF CHANGES WORK!
   453  01c1  2a1100                ld hl, (p1)         ; Loads P1.y into h and p1.x into l
   454  01c4  ed5b0f00              ld de, (p0)         ; Loads p0.y into d and p0.x into e
   455  01c8  7c                    ld a, h             ; Loads p1.y into a
   456  01c9  92                    sub d               ; p1.y - p0.y = deltay
   457  01ca  57                    ld d, a             ; Stores deltay into d
   458                              ;jp _stop            ; DEBUG: IT SEEMS IX GOT A BIT MESSED UP HERE... ix+0 HAS 3C02 WHICH ARE VALUES FROM THE OTHER ix START ADDRESS!
   459  01cb  1816                  jr pri_tri_i        ; Make sure pri_tri_i takes l and e as x rather than hl and bc as in the original code
   460                          
   461                          pri_tri_p1p2:           ; Initialises the line p1-p2
   462  01cd  2a1300                ld hl, (p2)         ; Loads P2.y into h and p2.x into l
   463  01d0  ed5b1100              ld de, (p1)         ; Loads p1.y into d and p1.x into e
   464  01d4  7c                    ld a, h             ; Loads p2.y into a
   465  01d5  92                    sub d               ; p2.y - p1.y = deltay
   466  01d6  57                    ld d, a             ; Stores deltay into d
   467  01d7  180a                  jr pri_tri_i        ; Make sure pri_tri_i takes l and e as x rather than hl and bc as in the original code
   468                          
   469                          pri_tri_p0p2:           ; Initialises the line p0-p2 (actually p2-p0)
   470  01d9  2a1300                ld hl, (p2)         ; Loads P2.y into h and p2.x into l
   471  01dc  ed5b0f00              ld de, (p0)         ; Loads p0.y into d and p0.x into e
   472  01e0  7c                    ld a, h             ; Loads p2.y into a
   473  01e1  92                    sub d               ; p2.y - p0.y = deltay
   474  01e2  57                    ld d, a             ; Stores deltay into d
   475                              ;jp _stop            ; DEBUG: ALL GOOD UP TO HERE
   476                              ;jr pri_tri_i        ; Unnecessary here as pri_tri_i is right below
   477                          
   478                          
   479                          ; L and E = x1 and x2, d = deltay
   480                          pri_tri_i:              ; Generic primitive triangle initialisation
   481                          
   482                          
   483                          
   484  01e3  dd7300            	ld (ix + XCoord), e      ; Stores first x from calling code back into the address - DEBUG: ix+0 has 5A here
   485  01e6  7d                    ld a, l             ; Loads the second x from calling code into a
   486  01e7  93                    sub e               ; Subtract both x to get to deltax
   487  01e8  67                    ld h, a             ; h now has deltax
   488  01e9  0e00                  ld c, 0x00          ; Zeroes c
   489                              ;jp _stop            ; DEBUG: ALL GOOD UP TO HERE - WITH OUR TEST TRIANGLE deltax is POS, so goes to seq1
   490  01eb  f2f301                jp p, pri_tri_i_seq1;
   491  01ee  ed44                  neg                 ; Neg a (which still has deltax)
   492  01f0  67                    ld h, a             ; Stores new neg'ed deltax
   493  01f1  0e01                  ld c, 0x01          ; c = 1
   494                          pri_tri_i_seq1:
   495  01f3  7c                    ld a, h             ; Loads deltax into a
   496  01f4  ba                    cp d                ; Compares with deltay, if no carry, deltax > deltay
   497                              ;jp _stop            ; DEBUG: ALL GOOD UP TO HERE. deltax < deltay (10 < 120) so we will set a carry here
   498  01f5  3005                  jr nc, pri_tri_i_seq2   ; Jumps to seq2 in the code skipping next part
   499  01f7  7c                    ld a, h             ; If deltay > deltax we swap them around
   500  01f8  62                    ld h, d             ; Swapping...
   501  01f9  57                    ld d, a             ; deltax and deltay are now swapped
   502  01fa  cbc9                  set 1, c            ; And we set the deltay > deltax flag this way
   503                              ;jp _stop            ; DEBUG: ALL GOOD UP TO HERE. deltay (d) has 0A, deltax (h) has 78, x (ix+0) has 5A, c has 02
   504                          pri_tri_i_seq2:
   505  01fc  dd7401                ld (ix + DeltaX), h      ; We store back deltax into its place in memory for the current line
   506  01ff  dd7202                ld (ix + DeltaY), d      ; We store back deltay into its place in memory for the current line
   507                              ;SRL H RR L !!! *** NEEDS DOUBLE CHECKING THIS
   508  0202  cb3c                  srl h               ; error = error / 2
   509                          
   510  0204  dd7403                ld (ix + Error), h      ; New error stored into its place in memory for the current line
   511  0207  dd7104                ld (ix + Flags), c      ; New flags stored into its place in memory for the current line
   512                              ;jp _stop            ; DEBUG: ALL GOOD UP TO HERE. x (ix+0) has 5A, deltax (ix+1) has 78, deltay (ix+2) has 0A, error (ix+3) has 3C (half of deltay), flags (ix+4) has 02, ix has 94F8
   513  020a  c9                    ret
   514                          
   515                          pri_tri_lc:
   516  020b  ddcb044e              bit 1, (ix + Flags)     ; Return the correct loop counter by checking the flag state storage, if the value in ix + Flags has a bit 1 on pos 1
   517  020f  2804                  jr z, pri_tri_lc_seq; If loop counter returns zero, jump
   518  0211  dd4601                ld b, (ix + DeltaX)      ; Loads deltax into b for looping
   519  0214  c9                    ret
   520                          pri_tri_lc_seq:
   521  0215  dd4602                ld b, (ix + DeltaY)      ; Loads deltay into b for looping
   522                              ;jp _stop            ; DEBUG: SEEMS LIKE ALL GOOD UP TO HERE?
   523  0218  c9                    ret
   524                          
   525                              ; E and C
   526                          
   527                          ;=================================================================================================
   528                          ; Quicker version setting bank at the start
   529                          ; L = Y, IYL = colour
   530                          ; C = X start, E = X end
   531                          ;=================================================================================================
   532                          pri_line_hor_quick:          	; A horizontal line drawing routine
   533  0219  7b                    ld a, e         	    	; Loads x2 into a
   534  021a  91                    sub c   		            ; Subtracts x1 to get length of line
   535  021b  c8                    ret z               		; If x2 - x1 = 0, we have no line to draw, end it.
   536  021c  3818              	jr c, pri_line_back		; If carry is set, we are drawing right to left, so jump to pri_line_back
   537                          
   538  021e  47                	ld b, a             		; Stores length of line as loop counter in b
   539  021f  69                    ld l,c
   540  0220  7c                	ld a, h 				    ; 0-31 per bank (8k)
   541  0221  e6e0              	and %11100000			    ; 3 bits for the 8 banks we can use
   542  0223  ed23              	swapnib
   543  0225  0f                	rrca
   544  0226  c612              	add a, START_8K_BANK		; 8L bank for L2
   545  0228  ed9250            	nextreg MMU_REGISTER_0,a  	; Set bank to write into
   546  022b  7c                	ld a, h
   547  022c  e61f              	and %00011111 		        ; This is our y (0-31)
   548  022e  67                	ld h, a 				    ; Puts y it back in h
   549  022f  fd7d                  ld a, iyl                   ; Loads colour from iyl into a
   550                          
   551                          ; do our loop
   552                          @qloop:
   553  0231  77                	ld (hl), a			        ; Draw our pixel
   554  0232  2c                    inc l               		; Increases x1
   555  0233  10fc                  djnz @qloop 					; Decrease loop counter and jump back to draw next pixel
   556  0235  c9                    ret
   557                          
   558                          pri_line_back:
   559                          ;=================================================================================================
   560  0236  ed44              	neg
   561  0238  47                	ld b, a             		; Stores length of line as loop counter in b
   562  0239  69                    ld l,c
   563  023a  7c                	ld a, h 				    ; 0-31 per bank (8k)
   564  023b  e6e0              	and %11100000			    ; 3 bits for the 8 banks we can use
   565  023d  ed23              	swapnib
   566  023f  0f                	rrca
   567  0240  c612              	add a, START_8K_BANK		; 8L bank for L2
   568  0242  ed9250            	nextreg MMU_REGISTER_0,a  	; Set bank to write into
   569  0245  7c                	ld a, h
   570  0246  e61f              	and %00011111 		        ; This is our y (0-31)
   571  0248  67                	ld h, a 				    ; Puts y it back in h
   572  0249  fd7d                  ld a, iyl                   ; Loads colour from iyl into a
   573                          
   574                          ; do our loop
   575                          @qloop2:
   576  024b  77                	ld (hl), a			        ; Draw our pixel
   577  024c  2d                    dec l               		; Increases x1
   578  024d  10fc                  djnz @qloop2 					; Decrease loop counter and jump back to draw next pixel
   579  024f  c9                    ret
   580                          
   581                          
   582                          ;=================================================================================================
   583                          ;    HL = YX
   584                          ;=================================================================================================
   585                          pri_line_hor:           ; bc has x1 on c; de has x2 on e
   586  0250  7b                    ld a, e             ; Loads x2 into a
   587  0251  91                    sub c               ; Subtracts x1 to get length of line
   588  0252  c8                    ret z               ; If x2 - x1 = 0, we have no line to draw, end it.
   589                          
   590  0253  47                    ld b, a             ; Stores length of line as loop counter in b
   591  0254  69                    ld l, c             ; h already has y; loads x1 into l, so PlotPixel8K has y,x into h,l
   592                          pri_line_hor_loop:      ; Start drawing!
   593                              ;jp _stop            ; DEBUG: OUR FIRST TIME HERE WE HAVE x1=5A, x2=5B, y=3C CORRECT | BUT x1 ISN'T INCREASING AFTER THIS IS EXECUTED...
   594  0255  4c                    ld c, h             ; Let's preserve h since PlotPixel8K destroys it
   595  0256  cd5500                call PlotPixel8K    ; Draw! Yey!
   596  0259  61                    ld h, c             ; Restore h after PlotPixel8K's execution
   597  025a  2c                    inc l
   598  025b  10f8                  djnz pri_line_hor_loop; Decrease loop counter and jump back to draw next pixel
   599  025d  c9                    ret
   600                          
   601                          ;=================================================================================================
   602                          ;extern void fillTrigL2(Point pt0, Point pt1, Point pt2, uint8_t colour) __z88dk_callee;
   603                          ; A filled triangle drawing routine
   604                          ;=================================================================================================
   605                          ;PUBLIC _fillTrigL2, fillTrigL2
   606                          ;_fillTrigL2:            ; The triangle drawns from top to bottom, we need to ensure p0 < p1 < p2 on its y, so we order it as such
   607                          ;    p0: defw 0          ; Variable (mem address) to store p0
   608                          ;    p1: defw 0          ; Variable (mem address) to store p1
   609                          ;    p2: defw 0          ; Variable (mem address) to store p2
   610                          ;    x01: defw 0xFA00    ; Memory start of x01 array is 64000
   611                          ;    x12: defw 0xFAC0    ; Memory start of x12 array is 64192
   612                          ;    x02: defw 0xFB80    ; Memory start of x02 array is 64384
   613                          ;    pop iy              ; Pops sp into iy
   614                          ;    pop hl              ; Pops p0.y and p0.x into hl
   615                          ;    pop de              ; Pops p1.y and p1.x into de
   616                          ;    ld a, d             ; Loads p1.y into a
   617                          ;    cp h                ; Compares p1.y with p0.y
   618                          ;    jr nc, _seq1        ; If p1.y > p0.y, no need to swap, jump
   619                          ;    ex de, hl           ; Swap p0 and p1, de now has the largest y of the two
   620                          ;    ;jp _stop
   621                          ;_seq1:                  ; Here we have p0.y < p1.y | h < d, now we need to check p2
   622                          ;    pop bc              ; Pops p2.y and p2.x into bc
   623                          ;    ld a, b             ; Loads p2.y into a
   624                          ;    cp d                ; Compares p2.y with p1.y
   625                          ;    jr nc, _seq2        ; If p2.y > p1.y, and here we already have p1.y > p0.y, we are done and jump out
   626                          ;    push bc             ; If p2.y < p1.y we need to swap p2 with p1, so we push p2 into stack
   627                          ;    push de             ; Push p1 into stack
   628                          ;    pop bc              ; Pop p1 into bc, becoming the new p2 > p1 on y
   629                          ;    pop de              ; Pop p2 into de, becoming the new p1 < p2 on y
   630                          ;    ld a, d             ; Lastly, we need to compare the new p1 < p0, if not swap them
   631                          ;    cp h                ; Compares the new p1.y with p0.y
   632                          ;    jr nc, _seq2        ; If p1.y > p0.y, no need to swap, jump
   633                          ;    ex de, hl           ; Swap p0 and p1. Now we have p0 < p1 < p2 on the y axis (lh < de < bc)
   634                          ;    ;jp _stop           DEBUG: All good here: hl 3C5A | de 7896 | bc B464 -- the correct testing coords ******
   635                          ;_seq2:
   636                          ;    ld (p0), hl         ; Stores p0
   637                          ;    ld (p1), de         ; Stores p1
   638                          ;    ld (p2), bc         ; Stores p2
   639                          ;    pop bc              ; Pops colour value into c
   640                          ;    push iy             ; Restores stack
   641                          ;    ld iyl, c           ; Loads colour into iyl
   642                          ;    ;jp _stop           DEBUG: All good here
   643                          ;
   644                          ;fillTrigL2:             ; We begin with certainty that p0 < p1 < p2 on y
   645                          ;    nop
   646                          ;interpolate_p0:         ; Interpolates p0.y, p0.x (hl) with p1.y, p1.x (de) and fills memory in iy with the interpolations
   647                          ;    ld iy, x01          ; Sets the starting address of the array x01 at 64000 (FA00)
   648                          ;    ld a, d             ; Loads p1.y into a for comparison with p0.y
   649                          ;    cp h                ; Compares p0.y with p1.y
   650                          ;    jr nz, inter_p0_1   ; If Z is not set, jump. If it is, p0.y = p1.y, do we just return p0.x
   651                          ;    ld (iy), l          ; Return p0.x only, that's all, by loading it into the array x01 kept in memory
   652                          ;    ret                 ; We are done
   653                          ;inter_p0_1:
   654                          ;    sub h               ; We have got p0.y on h and p1.y on d as we just compared them, thus a now has deltay
   655                          ;    ld b, a             ; Loads deltay into b
   656                          ;    ld a, e             ; Loads p1.x into e
   657                          ;    sub l               ; Subtracts p1.x - p0.x to get deltax
   658                          ;    ld c, a             ; Loads deltax into c
   659                          ;    ;Self modify here to reuse deltax befor we destroy it
   660                          ;
   661                          ;    ret
   662                          
