C:/Users/NTHunter/AppData/Local/Temp/zcc00005F981AE92.asm:
     1                          MODULE main_asm
     2                          LINE 0, "main.asm"
main.asm:
                                
     1                          INCLUDE "globals.inc"
globals.inc:
     1                          
     2                          START_16K_BANK = 9
     3                          START_8K_BANK = 18  ; START_16K_BANK*2
     4                          
     5                          MMU_REGISTER_0 = 0x50
     6                          MMU_REGISTER_1 = 0x51
     7                          MMU_REGISTER_2 = 0x52
     8                          MMU_REGISTER_3 = 0x53
     9                          MMU_REGISTER_4 = 0x54
    10                          MMU_REGISTER_5 = 0x55
    11                          MMU_REGISTER_6 = 0x56
    12                          MMU_REGISTER_7 = 0x57
    13                          
main.asm:
     2                          
     3                          SECTION code_user    ;; put in main binary
     4  0000  00                EXTERN  _x1:        db  0
     5  0001  00                EXTERN  _y1:        db  0
     6  0002  00                EXTERN  _x2:        db  0
     7  0003  00                EXTERN  _y2:        db  0
     8  0004  00                EXTERN  _colour:    db  0
     9                          
    10                          
    11                          ; extern void stop(void)
    12                          PUBLIC _stop
    13                          _stop:
    14                          
    15  0005  c30500                jp _stop
    16                          
    17                          
    18                          ; extern void setCPU(void)
    19                          PUBLIC _setCPU
    20                          _setCPU:
    21                          
    22                              ;;NEXTREG 03h,%00110011 ; Set machine to Spectrum Next
    23  0008  ed910703              NEXTREG 07h,3           ; Set CPU to 28MHz
    24  000c  c9                    RET
    25                          
    26                          
    27                          ; void initL2(void)
    28                          PUBLIC _initL2
    29                          _initL2:
    30                          
    31                              ; Enable Layer 2
    32  000d  013b12                LD BC, 0x123B
    33  0010  3e02                  LD A, 2
    34  0012  ed79                  OUT (C), A
    35                          
    36                              ; Setup starting Layer2 16K bank
    37  0014  ed911209              NEXTREG 12h, 9
    38  0018  c9                    RET
    39                          
    40                          
    41                          ; void clearL2(unsigned char colour) __z88dk_fastcall
    42                          ; param is in L if it's 8-bit, HL if it's 16-bit, DEHL if it's 32-bit.
    43                          PUBLIC _clearL2
    44                          _clearL2:
    45                          
    46  0019  1600                  LD D, 0             ; D=Y, start at top of the screen
    47                          
    48                          nextY:
    49                              ;Calculate bank number and swap it in
    50  001b  7a                    LD A, D             ; Copy current Y to A
    51  001c  e6e0                  AND %11100000       ; 32100000 (3MSB = bank number)
    52  001e  07                    RLCA                ; 21000003
    53  001f  07                    RLCA                ; 10000032
    54  0020  07                    RLCA                ; 00000321
    55  0021  c612                  ADD A, START_8K_BANK    ; A=bank number to swap in
    56  0023  ed9256                NEXTREG 56h, A      ; Swap bank
    57                          
    58                              ; Convert DE (yx) to screen memory location starting at $C000
    59  0026  d5                    PUSH DE             ; (DE) will be changed to bank offset
    60  0027  7a                    LD A, D             ; Copy current Y to A
    61  0028  e61f                  AND %00011111       ; Discard bank number
    62  002a  f6c0                  OR 0xC0             ; Screen starts at $C000
    63  002c  57                    LD D, A             ; D=high byte for $C000 screen memory
    64                          
    65                              ; Loop X through 0..255, we dont have to deal with bank swapping
    66                              ; here because it only occurs when changing Y
    67  002d  1e00                  LD E, 0             ; X=0 (X is E, Y is D)
    68                          
    69                          nextX:
    70  002f  7d                    LD A, L             ; A=current X
    71  0030  12                    LD (DE), A          ; Use L as colour. Variable is passed via DEHL - L if its 8-bit, HL if its 16-bit, DEHL if its 32-bit.
    72  0031  7b                    LD A, E             ; A=current X
    73  0032  1c                    INC E               ; Increment to next X
    74  0033  20fa                  JR NZ, nextX        ; Loop to nextX until E rolls over
    75                          
    76                              ; Continue with next line or exit
    77  0035  d1                    POP DE              ; Restore DE to coordinates
    78  0036  14                    INC D               ; Increment to next Y
    79  0037  7a                    LD A, D             ; A=current Y
    80  0038  fec0                  CP 192              ; Did we just complete last line?
    81  003a  da1b00                JP C, nextY         ; No, continue with next line
    82  003d  c9                    RET
    83                          
    84                          
    85                          ; extern void PlotPixel8K(uint8_t xcoord, uint8_t ycoord, uint8_t colour) __z88dk_callee
    86                          PUBLIC _PlotPixel8K, PlotPixel8K
    87                          _PlotPixel8K:
    88                          
    89                              ;jp _PlotPixel8K
    90  003e  e1                   	pop hl          ; Loads the stack value (sp) into hl for restoring later and moves variables into top of stack
    91  003f  d1                   	pop de          ; Loads next stack entry into e = x, d = y
    92  0040  3b                   	dec sp          ; Moves the stack up 1 byte, discarding a value and getting us to the third param, colour
    93  0041  e3                   	ex (sp), hl     ; Restores the original value of the stack from hl, and puts the colour on h from the stack
    94  0042  eb                   	ex de, hl       ; Put y and x into hl and the colour into d
    95  0043  fd6a                  ld iyl, d       ; Puts colour into iyl in order to free d for the drawline
    96                          
    97                          PlotPixel8K:
    98                          ;===========================================================================
    99                          ;	HL = YX, IYL = colour -- IMPORTANT: DESTROYS H (and A)
   100                          ;===========================================================================
   101                          
   102  0045  7c                	ld a, h 				    ; 0-31 per bank (8k)
   103  0046  e6e0              	and %11100000			    ; 3 bits for the 8 banks we can use
   104  0048  ed23              	swapnib
   105  004a  0f                	rrca
   106  004b  c612              	add a, START_8K_BANK		; 8L bank for L2
   107  004d  ed9250            	nextreg MMU_REGISTER_0,a  	; Set bank to write into
   108  0050  7c                	ld a, h
   109  0051  e61f              	and %00011111 		        ; This is our y (0-31)
   110  0053  67                	ld h, a 				    ; Puts y it back in h
   111  0054  fd7d                  ld a, iyl                   ; Loads colour from iyl into a
   112  0056  77                	ld (hl), a			        ; Draw our pixel
   113  0057  c9                	ret
   114                          
   115                          
   116                          PlotPixel8KCol:
   117                          ;===========================================================================
   118                          ; This has no C calls and must be called from assembly
   119                          ;
   120                          ;	HL = YX -- IMPORTANT: DESTROYS H (and A)
   121                          ; We preset the colour so we can use it directly
   122                          ; by setting plotPixel8KColour with self-modifying code
   123                          ;===========================================================================
   124                          
   125  0058  7c                	ld a, h 				    ; 0-31 per bank (8k)
   126  0059  e6e0              	and %11100000			    ; 3 bits for the 8 banks we can use
   127  005b  ed23              	swapnib
   128  005d  0f                	rrca
   129  005e  c612              	add a, START_8K_BANK		; 8L bank for L2
   130  0060  ed9250            	nextreg MMU_REGISTER_0,a  	; Set bank to write into
   131  0063  7c                	ld a, h
   132  0064  e61f              	and %00011111 		        ; This is our y (0-31)
   133  0066  67                	ld h, a 				    ; Puts y it back in h
   134                          plotPixel8KColour:
   135  0067  3600                  ld (hl), 0			        ; Draw our pixel (colour is going to be set by automodifying the code)
   136  0069  c9                	ret
   137                          
   138                          
   139                          ; extern void drawL2(uint8_t x1coord, uint8_t y1coord, uint8_t x2coord, uint8_t y2coord, uint8_t colour) __z88dk_callee
   140                          PUBLIC _drawL2, drawL2
   141                          _drawL2:
   142                          
   143                          ; or, even better, set the colour in AF, and store that in the PlotPixel8KCol
   144  006a  c1                    pop bc          ; Loads the stack value (sp) into bc for restoring later and moves variables into top of stack
   145  006b  e1                    pop hl          ; Loads y1x1 into hl
   146  006c  d1                    pop de          ; Loads y2x2 into de
   147  006d  fde1                  pop iy          ; Use iyl for the colour
   148  006f  c5                    push bc         ; Restores the stack value from bc
   149                          
   150                          drawL2:
   151                          ;=========================================================================
   152                          ;   HL = Y1X1, DE = Y2X2, IYL = colour
   153                          ;=========================================================================
   154  0070  fd7d                  ld a, iyl           ; Loads colour into a
   155  0072  326800                ld (plotPixel8KColour + 1), a ; Store the colour in the plotPixel8KColour through self-modifying the code
   156  0075  7a                    ld a, d             ; Loads y2 into a. We'll see if we need to swap coords to draw downwards
   157  0076  bc                    cp h                ; Compares y1 with y2
   158  0077  3001                  jr nc, draw_line_1  ; No need to swap the coords, jump
   159  0079  eb                    ex de, hl           ; Swapped coordinates to ensure y2 > y1, so we draw downwards
   160                          draw_line_1:
   161  007a  7a                    ld a, d             ; Loads y2 into a
   162  007b  94                    sub h               ; y2 - y1
   163  007c  47                    ld b, a             ; b becomes deltay
   164  007d  7b                    ld a, e             ; Loads x2 into a
   165  007e  95                    sub l               ; x2 - x1, a now contains deltax
   166  007f  3805                  jr c, draw_line_x1  ; If carry is set (x2 - x1 is negative) we are drawing right to left
   167  0081  4f                    ld c, a             ; c becomes deltax
   168  0082  3e2c                  ld a, 0x2C          ; Replaces original code above to increase x1 as we're drawing left to right. 0x2C is inc l, and we modify the code to have this
   169  0084  1805                  jr draw_line_x2     ; Skips next part of the code
   170                          draw_line_x1:
   171  0086  ed44                  neg                 ; deltax in a is negative, make it positive
   172  0088  4f                    ld c, a             ; c becomes deltax
   173  0089  3e2d                  ld a, 0x2D          ; Replaces original code above to decrease x1 as we're drawing right to left. Self-modifying, puts dec l into the code
   174                          draw_line_x2:
   175  008b  32b100                ld (draw_line_q1_m2), a ; a contains either inc l or dec l, and modifies the code accordingly
   176  008e  32c800                ld (draw_line_q2_m2), a ; Same as above for verticalish lines
   177  0091  78                    ld a, b             ; We'll check if deltay (b) and deltax (ixl) are 0
   178  0092  b1                    or c                ; Checking...
   179  0093  ca5800                jp z, PlotPixel8KCol    ; When reaching zero, we're done, draw last pixel
   180                              ; STATUS: b = deltay | c = deltax | d is free
   181                          draw_line_q:            ; Find out what kind of diagonal we're dealing with, if horizontalish or verticalish
   182  0096  78                    ld a, b             ; Loads deltay into a
   183  0097  b9                    cp c                ; Compares with deltax
   184  0098  301d                  jr nc, draw_line_q2 ; If no cary, line is verticalish (or perfectly diagonal)
   185                          draw_line_q1:
   186  009a  79                    ld a, c             ; a becomes deltax
   187  009b  32ae00                ld (draw_line_q1_m1 + 1), a ; Self-modifying code: loads deltax onto the value of the opcode, in this case the loop
   188  009e  48                    ld c, b             ; c becomes deltay
   189  009f  47                    ld b, a             ; b becomes deltax for the loop counter
   190  00a0  58                    ld e, b             ; e becomes deltax temporarily...
   191  00a1  cb3b                  srl e               ; now e = deltax / 2 -- aka Bresenham's error
   192                          ; loop uses d as temp, hl bc e
   193                          draw_line_q1_l:
   194  00a3  54                    ld d, h             ; OPTIMISE? Backs up h into d
   195  00a4  cd5800                call PlotPixel8KCol ; PlotPixel8KCol destroys h, so we need to preserve it
   196  00a7  62                    ld h, d             ; OPTIMISE? Restores h from d
   197  00a8  7b                    ld a, e             ; Loads Bresenham's error into a
   198  00a9  91                    sub c               ; error - deltay
   199  00aa  5f                    ld e, a             ; Stores new error value into e
   200  00ab  3004                  jr nc, draw_line_q1_m2  ; If there's no cary, jump
   201                          draw_line_q1_m1:
   202  00ad  c600                  add a, 0            ; This 0 here will be modified by the self-modifying code above e = e + deltax
   203  00af  5f                    ld e, a             ; Stores new error e = e + deltax back into e
   204  00b0  24                    inc h               ; Increases line slope by adding to y1
   205                          draw_line_q1_m2:        ; This either increases or decreases l by the self modified code that targeted this
   206  00b1  2c                    inc l               ; Self-modified code: It will be either inc l or dec l depending on direction of horizontal drawing
   207                          draw_line_q1_s:         ; Tests to loop and keep drawing line
   208  00b2  10ef                  djnz draw_line_q1_l ; Loops until line is drawn and zero flag set
   209  00b4  c35800                jp PlotPixel8KCol    ; This is the last pixel, draws and quits
   210                          draw_line_q2:           ; Here the line is verticalish or perfectly diagonal
   211  00b7  32c700                ld (draw_line_q2_m1 + 1), a ; Self-modifies the code to store deltay in the loop
   212  00ba  58                    ld e, b             ; e = deltay
   213  00bb  cb3b                  srl e               ; e = deltay / 2 (Bressenham's error)
   214                          ; loop uses d as temp, hl bc e
   215                          draw_line_q2_l:         ; The main drawline loop for this case
   216  00bd  54                    ld d, h             ; OPTIMISE? Backs up h into d
   217  00be  cd5800                call PlotPixel8KCol    ; PlotPixel8KCol destroys h, so we need to preserve it
   218  00c1  62                    ld h, d             ; OPTIMISE? Restores h from d
   219  00c2  7b                    ld a, e             ; Adds deltax to the error
   220  00c3  91                    sub c               ; As above
   221  00c4  3003                  jr nc, draw_line_q2_s   ; If we don't get a carry, skip the next part
   222                          draw_line_q2_m1:
   223  00c6  c600                  add a, 0            ; This is a target of self-modified code: e = e + deltax
   224                          draw_line_q2_m2:
   225  00c8  2c                    inc l               ; Self-modified code: It will be either inc l or dec l depending on direction of horizontal drawing
   226                          draw_line_q2_s:
   227  00c9  5f                    ld e, a             ; Restores the error value back in
   228  00ca  24                    inc h               ; Increases y1
   229  00cb  10f0                  djnz draw_line_q2_l ; While zero flag not set, loop back to main loop
   230  00cd  c35800                jp PlotPixel8KCol   ; This is the last pixel drawn, all done
   231                          
   232                          
   233                          PUBLIC _trigL2, trigL2
   234                          _trigL2:
   235  00d0  fde1                  pop iy              ; Pops sp into iy
   236  00d2  e1                    pop hl              ; Pops p0.y and p0.x into hl
   237                              ;ld (l1 + 1), hl     ; Self-modifying code, loads hl into l1: hl (l1 start)
   238  00d3  22f900                ld (l3 + 4), hl     ; Self-modifying code, loads hl into l3: de (l3 end)
   239  00d6  d1                    pop de              ; Pops p1.y and p1.x into de
   240                              ;ld (l1 + 4), de     ; Self-modifying code, loads de into l1: de (l1 end)
   241  00d7  ed53ed00              ld (l2 + 1), de     ; Self-modifying code, loads de into l2: hl (l2 start)
   242  00db  c1                    pop bc              ; Pops p2.y and p2.x into bc
   243  00dc  ed43f000              ld (l2 + 4), bc     ; Self-modifying code, loads bc into l2: de (l2 end)
   244  00e0  ed43f600              ld (l3 + 1), bc     ; Self-modifying code, loads cd into l3: hl (l3 start)
   245  00e4  c1                    pop bc              ; Pops colour value into c
   246  00e5  fde5                  push iy             ; Restore stack
   247  00e7  fd69                  ld iyl, c           ; Loads colour into iyl
   248                          
   249                          trigL2:
   250                          l1:                     ; Line 1
   251  00e9  cd7000                call drawL2         ; Because hl and de are already set correctly, just draw it
   252                          l2:                     ; Line 2
   253  00ec  210000                ld hl, 0            ; Self-modified target from above
   254  00ef  110000                ld de, 0            ; Seld-modified target from above
   255  00f2  cd7000                call drawL2         ; Draws line with the modified hl and de with the self-modifying code
   256                          l3:                     ; Line 3
   257  00f5  210000                ld hl, 0            ; Self-modified target from above
   258  00f8  110000                ld de, 0            ; Self-modified target from above
   259  00fb  c37000                jp drawL2           ; Draws line with the modified hl and de with the self-modifying code
   260  00fe  c9                    ret                 ; We're done, return nicely
   261                          
   262                          
   263                          ;PUBLIC _trigL2, trigL2
   264                          ;_trigL2:
   265                          ;    pop iy              ; Pops sp into iy
   266                          ;    pop hl              ; Pops p0.y and p0.x into hl
   267                          ;    ld (iy + 02h), l    ; Loads p0.x into iy + 2
   268                          ;    ld (iy + 03h), h    ; Loads p0.y into iy + 3
   269                          ;    pop de              ; Pops p1.y and p1.x into de
   270                          ;    ld (iy + 04h), e    ; Loads p1.x into iy + 4
   271                          ;    ld (iy + 05h), d    ; Loads p1.y into iy + 5
   272                          ;    pop bc              ; Pops p2.y and p2.x into bc
   273                          ;    ld (iy + 06h), c    ; Loads p2.x into iy + 6
   274                          ;    ld (iy + 07h), b    ; Loads p2.y into iy + 7
   275                          ;    pop bc              ; Pops colour into c
   276                          ;    ld ixl, c           ; Loads colour into ixl
   277                          ;
   278                          ;trigL2:
   279                          ;    call drawL2         ; hl and de already have p0.y, p0,x, p1,y and p1,x
   280                          ;    ld l, (iy + 04h)
   281                          ;    ld h, (iy + 05h)
   282                          ;    ld e, (iy + 06h)
   283                          ;    ld d, (iy + 07h)
   284                          ;    call drawL2
   285                          ;    ld l, (iy + 06h)
   286                          ;    ld h, (iy + 07h)
   287                          ;    ld e, (iy + 02h)
   288                          ;    ld d, (iy + 03h)
   289                          ;    call drawL2
   290                          ;    ld a, 255
   291                          ;    push iy
   292                          ;    ret
   293                          
