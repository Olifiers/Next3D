C:/Users/NTHunter/AppData/Local/Temp/zcc000050F0CFB62.asm:
     1                          MODULE main_asm
     2                          LINE 0, "main.asm"
main.asm:
                                
     1                          INCLUDE "globals.inc"
globals.inc:
     1                          
     2                          START_16K_BANK = 9
     3                          START_8K_BANK = 18  ; START_16K_BANK*2
     4                          
     5                          MMU_REGISTER_0 = 0x50
     6                          MMU_REGISTER_1 = 0x51
     7                          MMU_REGISTER_2 = 0x52
     8                          MMU_REGISTER_3 = 0x53
     9                          MMU_REGISTER_4 = 0x54
    10                          MMU_REGISTER_5 = 0x55
    11                          MMU_REGISTER_6 = 0x56
    12                          MMU_REGISTER_7 = 0x57
    13                          
main.asm:
     2                          
     3                          SECTION code_user    ;; put in main binary
     4  0000  00                EXTERN  _x1:        db  0
     5  0001  00                EXTERN  _y1:        db  0
     6  0002  00                EXTERN  _x2:        db  0
     7  0003  00                EXTERN  _y2:        db  0
     8  0004  00                EXTERN  _colour:    db  0
     9                          
    10                          
    11                          ; extern void stop(void)
    12                          PUBLIC _stop
    13                          _stop:
    14                          
    15  0005  c30500                jp _stop
    16                          
    17                          
    18                          ; extern void setCPU(void)
    19                          PUBLIC _setCPU
    20                          _setCPU:
    21                          
    22                              ;;NEXTREG 03h,%00110011 ; Set machine to Spectrum Next
    23  0008  ed910703              NEXTREG 07h,3           ; Set CPU to 28MHz
    24  000c  c9                    RET
    25                          
    26                          
    27                          ; void initL2(void)
    28                          PUBLIC _initL2
    29                          _initL2:
    30                          
    31                              ; Enable Layer 2
    32  000d  013b12                LD BC, 0x123B
    33  0010  3e02                  LD A, 2
    34  0012  ed79                  OUT (C), A
    35                          
    36                              ; Setup starting Layer2 16K bank
    37  0014  ed911209              NEXTREG 12h, 9
    38  0018  c9                    RET
    39                          
    40                          
    41                          ; void clearL2(unsigned char colour) __z88dk_fastcall
    42                          ; param is in L if it's 8-bit, HL if it's 16-bit, DEHL if it's 32-bit.
    43                          PUBLIC _clearL2
    44                          _clearL2:
    45                          
    46  0019  1600                  LD D, 0             ; D=Y, start at top of the screen
    47                          
    48                          nextY:
    49                              ;Calculate bank number and swap it in
    50  001b  7a                    LD A, D             ; Copy current Y to A
    51  001c  e6e0                  AND %11100000       ; 32100000 (3MSB = bank number)
    52  001e  07                    RLCA                ; 21000003
    53  001f  07                    RLCA                ; 10000032
    54  0020  07                    RLCA                ; 00000321
    55  0021  c612                  ADD A, START_8K_BANK    ; A=bank number to swap in
    56  0023  ed9256                NEXTREG 56h, A      ; Swap bank
    57                          
    58                              ; Convert DE (yx) to screen memory location starting at $C000
    59  0026  d5                    PUSH DE             ; (DE) will be changed to bank offset
    60  0027  7a                    LD A, D             ; Copy current Y to A
    61  0028  e61f                  AND %00011111       ; Discard bank number
    62  002a  f6c0                  OR 0xC0             ; Screen starts at $C000
    63  002c  57                    LD D, A             ; D=high byte for $C000 screen memory
    64                          
    65                              ; Loop X through 0..255, we dont have to deal with bank swapping
    66                              ; here because it only occurs when changing Y
    67  002d  1e00                  LD E, 0             ; X=0 (X is E, Y is D)
    68                          
    69                          nextX:
    70  002f  7d                    LD A, L             ; A=current X
    71  0030  12                    LD (DE), A          ; Use L as colour. Variable is passed via DEHL - L if its 8-bit, HL if its 16-bit, DEHL if its 32-bit.
    72  0031  7b                    LD A, E             ; A=current X
    73  0032  1c                    INC E               ; Increment to next X
    74  0033  20fa                  JR NZ, nextX        ; Loop to nextX until E rolls over
    75                          
    76                              ; Continue with next line or exit
    77  0035  d1                    POP DE              ; Restore DE to coordinates
    78  0036  14                    INC D               ; Increment to next Y
    79  0037  7a                    LD A, D             ; A=current Y
    80  0038  fec0                  CP 192              ; Did we just complete last line?
    81  003a  da1b00                JP C, nextY         ; No, continue with next line
    82  003d  c9                    RET
    83                          
    84                          
    85                          ; extern void PlotPixel8K(uint8_t xcoord, uint8_t ycoord, uint8_t colour) __z88dk_callee
    86                          PUBLIC _PlotPixel8K, PlotPixel8K
    87                          _PlotPixel8K:
    88                          
    89                              ;jp _PlotPixel8K
    90  003e  e1                   	pop hl          ; Loads the stack value (sp) into hl for restoring later and moves variables into top of stack
    91  003f  d1                   	pop de          ; Loads next stack entry into e = x, d = y
    92  0040  3b                   	dec sp          ; Moves the stack up 1 byte, discarding a value and getting us to the third param, colour
    93  0041  e3                   	ex (sp), hl     ; Restores the original value of the stack from hl, and puts the colour on h from the stack
    94  0042  eb                   	ex de, hl       ; Put y and x into hl and the colour into d
    95  0043  dd6a                  ld ixl, d       ; Puts colour into ixl in order to free d for the drawline
    96                          
    97                          PlotPixel8K:
    98                          ;===========================================================================
    99                          ;	HL = YX, IXL = colour -- IMPORTANT: DESTROYS H (and A)
   100                          ;===========================================================================
   101                          
   102  0045  7c                	ld a, h 				    ; 0-31 per bank (8k)
   103  0046  e6e0              	and %11100000			    ; 3 bits for the 8 banks we can use
   104  0048  ed23              	swapnib
   105  004a  0f                	rrca
   106  004b  c612              	add a, START_8K_BANK		; 8L bank for L2
   107  004d  ed9250            	nextreg MMU_REGISTER_0,a  	; Set bank to write into
   108  0050  7c                	ld a, h
   109  0051  e61f              	and %00011111 		        ; This is our y (0-31)
   110  0053  67                	ld h, a 				    ; Puts y it back in h
   111  0054  dd7d                  ld a, ixl                   ; Loads colour from ixl into a
   112  0056  77                	ld (hl), a			        ; Draw our pixel
   113  0057  c9                	ret
   114                          
   115                          
   116                          ; extern void drawL2(uint8_t x1coord, uint8_t y1coord, uint8_t x2coord, uint8_t y2coord, uint8_t colour) __z88dk_callee
   117                          PUBLIC _drawL2, drawL2
   118                          _drawL2:
   119                          
   120  0058  dde1                  pop ix              ; Loads the stack value (sp) into ix for restoring later and moves variables into top of stack
   121  005a  e1                    pop hl              ; Loads y1x1 into hl
   122  005b  d1                    pop de              ; Loads y2x2 into de
   123  005c  c1                    pop bc              ; Loads colour into c
   124  005d  dde5                  push ix             ; Restores stack ret
   125                          
   126                          drawL2:
   127                          ;=========================================================================
   128                          ;   HL = Y1X1, DE = Y2X2, IXL = colour
   129                          ;=========================================================================
   130  005f  dd69                  ld ixl, c           ; Frees c (colour) for use by storing it into ixl
   131  0061  7a                    ld a, d             ; Loads y2 into a. We'll see if we need to swap coords to draw downwards
   132  0062  bc                    cp h                ; Compares y1 with y2
   133  0063  3001                  jr nc, draw_line_1  ; No need to swap the coords, jump
   134  0065  eb                    ex de, hl           ; Swapped coordinates to ensure y2 > y1, so we draw downwards
   135                          draw_line_1:
   136  0066  7a                    ld a, d             ; Loads y2 into a
   137  0067  94                    sub h               ; y2 - y1
   138  0068  47                    ld b, a             ; b becomes deltay
   139  0069  7b                    ld a, e             ; Loads x2 into a
   140  006a  95                    sub l               ; x2 - x1, a now contains deltax
   141  006b  3805                  jr c, draw_line_x1  ; If carry is set (x2 - x1 is negative) we are drawing right to left
   142  006d  4f                    ld c, a             ; c becomes deltax
   143  006e  3e2c                  ld a, 0x2C          ; Replaces original code above to increase x1 as we're drawing left to right. 0x2C is inc l, and we modify the code to have this
   144  0070  1805                  jr draw_line_x2     ; Skips next part of the code
   145                          draw_line_x1:
   146  0072  ed44                  neg                 ; deltax in a is negative, make it positive
   147  0074  4f                    ld c, a             ; c becomes deltax
   148  0075  3e2d                  ld a, 0x2D          ; Replaces original code above to decrease x1 as we're drawing right to left. Self-modifying, puts dec l into the code
   149                          draw_line_x2:
   150  0077  329c00                ld (draw_line_q1_m2), a ; a contains either inc l or dec l, and modifies the code accordingly
   151  007a  32b600                ld (draw_line_q2_m2), a ; Same as above for verticalish lines
   152  007d  78                    ld a, b             ; We'll check if deltay (b) and deltax (ixl) are 0
   153  007e  b1                    or c                ; Checking...
   154  007f  281f                  jr z, draw_line_p   ; There's no line to speak of, let's just draw a point and be done with it
   155                              ; STATUS: b = deltay | c = deltax | d is free
   156                          draw_line_q:            ; Find out what kind of diagonal we're dealing with, if horizontalish or verticalish
   157  0081  78                    ld a, b             ; Loads deltay into a
   158  0082  b9                    cp c                ; Compares with deltax
   159  0083  301f                  jr nc, draw_line_q2 ; If no cary, line is verticalish (or perfectly diagonal)
   160                          draw_line_q1:
   161  0085  79                    ld a, c             ; a becomes deltax
   162  0086  329900                ld (draw_line_q1_m1 + 1), a ; Self-modifying code: loads deltax onto the value of the opcode, in this case the loop
   163  0089  48                    ld c, b             ; c becomes deltay
   164  008a  47                    ld b, a             ; b becomes deltax for the loop counter
   165  008b  58                    ld e, b             ; e becomes deltax temporarily...
   166  008c  cb3b                  srl e               ; now e = deltax / 2 -- aka Bresenham's error
   167                          draw_line_q1_l:
   168  008e  54                    ld d, h             ; OPTIMISE? Backs up h into d
   169  008f  cd4500                call PlotPixel8K    ; PlotPixel8K destroys h, so we need to preserve it
   170  0092  62                    ld h, d             ; OPTIMISE? Restores h from d
   171  0093  7b                    ld a, e             ; Loads Bresenham's error into a
   172  0094  91                    sub c               ; error - deltay
   173  0095  5f                    ld e, a             ; Stores new error value into e
   174  0096  3004                  jr nc, draw_line_q1_m2  ; If there's no cary, jump
   175                          draw_line_q1_m1:
   176  0098  c600                  add a, 0            ; This 0 here will be modified by the self-modifying code above e = e + deltax
   177  009a  5f                    ld e, a             ; Stores new error e = e + deltax back into e
   178  009b  24                    inc h               ; Increases line slope by adding to y1
   179                          draw_line_q1_m2:        ; This either increases or decreases l by the self modified code that targeted this
   180  009c  2c                    inc l               ; Self-modified code: It will be either inc l or dec l depending on direction of horizontal drawing
   181                          draw_line_q1_m3:        ; Same as above
   182  009d  00                    nop
   183                          draw_line_q1_s:         ; Tests to loop and keep drawing line
   184  009e  10ee                  djnz draw_line_q1_l ; Loops until line is drawn and zero flag set
   185                          draw_line_p:            ; Plots the final pixel of the line if we are done with the loop above
   186  00a0  cd4500                call PlotPixel8K    ; While PlotPixel8K destroys h, this is the last pixel, thus we don't care
   187  00a3  c9                    ret
   188                          draw_line_q2:           ; Here the line is verticalish or perfectly diagonal
   189  00a4  32b500                ld (draw_line_q2_m1 + 1), a ; Self-modifies the code to store deltay in the loop
   190  00a7  58                    ld e, b             ; e = deltay
   191  00a8  cb3b                  srl e               ; e = deltay / 2 (Bressenham's error)
   192                          draw_line_q2_l:         ; The main drawline loop for this case
   193  00aa  54                    ld d, h             ; OPTIMISE? Backs up h into d
   194  00ab  cd4500                call PlotPixel8K    ; PlotPixel8K destroys h, so we need to preserve it
   195  00ae  62                    ld h, d             ; OPTIMISE? Restores h from d
   196  00af  b2                    or d                ; WHAT IS THIS? IS THIS SPECCY CODE?
   197  00b0  7b                    ld a, e             ; Adds deltax to the error
   198  00b1  91                    sub c               ; As above
   199  00b2  3004                  jr nc, draw_line_q2_s   ; If we don't get a carry, skip the next part
   200                          draw_line_q2_m1:
   201  00b4  c600                  add a, 0            ; This is a target of self-modified code: e = e + deltax
   202                          draw_line_q2_m2:
   203  00b6  2c                    inc l               ; Self-modified code: It will be either inc l or dec l depending on direction of horizontal drawing
   204                          draw_line_q2_m3:
   205  00b7  00                    nop
   206                          draw_line_q2_s:
   207  00b8  5f                    ld e, a             ; Restores the error value back in
   208  00b9  24                    inc h               ; Increases y1
   209  00ba  10ee                  djnz draw_line_q2_l ; While zero flag not set, loop back to main loop
   210  00bc  18e2                  jr draw_line_p      ; If zero flag is finally set, jump to draw our last pixel of the line and... Done
   211                          
