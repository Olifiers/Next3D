C:/Users/Flash/AppData/Local/Temp/zcc00007238F2E52.asm:
     1                          MODULE main_asm
     2                          LINE 0, "main.asm"
main.asm:
                                
     1                          INCLUDE "globals.inc"
globals.inc:
     1                          
     2                          START_16K_BANK = 9
     3                          START_8K_BANK = 18  ; START_16K_BANK*2
     4                          
     5                          MMU_REGISTER_0 = 0x50
     6                          MMU_REGISTER_1 = 0x51
     7                          MMU_REGISTER_2 = 0x52
     8                          MMU_REGISTER_3 = 0x53
     9                          MMU_REGISTER_4 = 0x54
    10                          MMU_REGISTER_5 = 0x55
    11                          MMU_REGISTER_6 = 0x56
    12                          MMU_REGISTER_7 = 0x57
    13                          
main.asm:
     2                          
     3                          SECTION code_user    ;; put in main binary
     4  0000  00                EXTERN  _x1:        db  0
     5  0001  00                EXTERN  _y1:        db  0
     6  0002  00                EXTERN  _x2:        db  0
     7  0003  00                EXTERN  _y2:        db  0
     8  0004  00                EXTERN  _colour:    db  0
     9                          
    10                          
    11                          ; extern void stop(void)
    12                          PUBLIC _stop
    13                          _stop:
    14                          
    15  0005  c30500                jp _stop
    16                          
    17                          
    18                          ; extern void setCPU(void)
    19                          PUBLIC _setCPU
    20                          _setCPU:
    21                          
    22                              ;;NEXTREG 03h,%00110011 ; Set machine to Spectrum Next
    23  0008  ed910703              NEXTREG 07h,3           ; Set CPU to 28MHz
    24  000c  c9                    RET
    25                          
    26                          
    27                          ; void initL2(void)
    28                          PUBLIC _initL2
    29                          _initL2:
    30                          
    31                              ; Enable Layer 2
    32  000d  013b12                LD BC, 0x123B
    33  0010  3e02                  LD A, 2
    34  0012  ed79                  OUT (C), A
    35                          
    36                              ; Setup starting Layer2 16K bank
    37  0014  ed911209              NEXTREG 12h, 9
    38  0018  c9                    RET
    39                          
    40                          
    41                          ; void clearL2(unsigned char colour) __z88dk_fastcall
    42                          ; param is in L if it's 8-bit, HL if it's 16-bit, DEHL if it's 32-bit.
    43                          PUBLIC _clearL2
    44                          _clearL2:
    45                          
    46  0019  1600                  LD D, 0             ; D=Y, start at top of the screen
    47                          
    48                          nextY:
    49                              ;Calculate bank number and swap it in
    50  001b  7a                    LD A, D             ; Copy current Y to A
    51  001c  e6e0                  AND %11100000       ; 32100000 (3MSB = bank number)
    52  001e  07                    RLCA                ; 21000003
    53  001f  07                    RLCA                ; 10000032
    54  0020  07                    RLCA                ; 00000321
    55  0021  c612                  ADD A, START_8K_BANK    ; A=bank number to swap in
    56  0023  ed9256                NEXTREG 56h, A      ; Swap bank
    57                          
    58                              ; Convert DE (yx) to screen memory location starting at $C000
    59  0026  d5                    PUSH DE             ; (DE) will be changed to bank offset
    60  0027  7a                    LD A, D             ; Copy current Y to A
    61  0028  e61f                  AND %00011111       ; Discard bank number
    62  002a  f6c0                  OR 0xC0             ; Screen starts at $C000
    63  002c  57                    LD D, A             ; D=high byte for $C000 screen memory
    64                          
    65                              ; Loop X through 0..255, we dont have to deal with bank swapping
    66                              ; here because it only occurs when changing Y
    67  002d  1e00                  LD E, 0             ; X=0 (X is E, Y is D)
    68                          
    69                          nextX:
    70  002f  7d                    LD A, L             ; A=current X
    71  0030  12                    LD (DE), A          ; Use L as colour. Variable is passed via DEHL - L if its 8-bit, HL if its 16-bit, DEHL if its 32-bit.
    72  0031  7b                    LD A, E             ; A=current X
    73  0032  1c                    INC E               ; Increment to next X
    74  0033  20fa                  JR NZ, nextX        ; Loop to nextX until E rolls over
    75                          
    76                              ; Continue with next line or exit
    77  0035  d1                    POP DE              ; Restore DE to coordinates
    78  0036  14                    INC D               ; Increment to next Y
    79  0037  7a                    LD A, D             ; A=current Y
    80  0038  fec0                  CP 192              ; Did we just complete last line?
    81  003a  da1b00                JP C, nextY         ; No, continue with next line
    82  003d  c9                    RET
    83                          
    84                          
    85                          ; extern void PlotPixel8K(uint8_t xcoord, uint8_t ycoord, uint8_t colour) __z88dk_callee
    86                          PUBLIC _PlotPixel8K, PlotPixel8K
    87                          _PlotPixel8K:
    88                          
    89                              ;jp _PlotPixel8K
    90  003e  e1                   	pop hl          ; Loads the stack value (sp) into hl for restoring later and moves variables into top of stack
    91  003f  d1                   	pop de          ; Loads next stack entry into e = x, d = y
    92  0040  3b                   	dec sp          ; Moves the stack up 1 byte, discarding a value and getting us to the third param, colour
    93  0041  e3                   	ex (sp), hl     ; Restores the original value of the stack from hl, and puts the colour on h from the stack
    94  0042  eb                   	ex de, hl       ; Put y and x into hl and the colour into d
    95                          ;    ld ixl, d       ; Puts colour into ixl in order to free d for the drawline
    96  0043  fd6a                  ld iyl, d       ; Puts colour into ixl in order to free d for the drawline
    97                          
    98                          PlotPixel8K:
    99                          ;===========================================================================
   100                          ;	HL = YX, IXL = colour -- IMPORTANT: DESTROYS H (and A)
   101                          ;===========================================================================
   102                          
   103  0045  7c                	ld a, h 				    ; 0-31 per bank (8k)
   104  0046  e6e0              	and %11100000			    ; 3 bits for the 8 banks we can use
   105  0048  ed23              	swapnib
   106  004a  0f                	rrca
   107  004b  c612              	add a, START_8K_BANK		; 8L bank for L2
   108  004d  ed9250            	nextreg MMU_REGISTER_0,a  	; Set bank to write into
   109  0050  7c                	ld a, h
   110  0051  e61f              	and %00011111 		        ; This is our y (0-31)
   111  0053  67                	ld h, a 				    ; Puts y it back in h
   112                          ;    ld a, ixl                   ; Loads colour from ixl into a
   113  0054  fd7d                  ld a, iyl                   ; Loads colour from ixl into a
   114  0056  77                	ld (hl), a			        ; Draw our pixel
   115  0057  c9                	ret
   116                          
   117                          
   118                          PlotPixel8KCol:
   119                          ;===========================================================================
   120                          ; This has no C calls and must be called from assembly
   121                          ;
   122                          ;	HL = YX -- IMPORTANT: DESTROYS H (and A)
   123                          ; we preset the colour so we can use it directly
   124                          ; by setting plotPixel8KColour
   125                          ;===========================================================================
   126                          
   127  0058  7c                	ld a, h 				    ; 0-31 per bank (8k)
   128  0059  e6e0              	and %11100000			    ; 3 bits for the 8 banks we can use
   129  005b  ed23              	swapnib
   130  005d  0f                	rrca
   131  005e  c612              	add a, START_8K_BANK		; 8L bank for L2
   132  0060  ed9250            	nextreg MMU_REGISTER_0,a  	; Set bank to write into
   133  0063  7c                	ld a, h
   134  0064  e61f              	and %00011111 		        ; This is our y (0-31)
   135  0066  67                	ld h, a 				    ; Puts y it back in h
   136                          plotPixel8KColour:
   137  0067  3600                  ld (hl), 0			        ; Draw our pixel (colour is already set in plotPixel8KColour)
   138  0069  c9                	ret
   139                          
   140                          
   141                          ; extern void drawL2(uint8_t x1coord, uint8_t y1coord, uint8_t x2coord, uint8_t y2coord, uint8_t colour) __z88dk_callee
   142                          PUBLIC _drawL2, drawL2
   143                          _drawL2:
   144                          
   145                          ;    pop ix              ; Loads the stack value (sp) into ix for restoring later and moves variables into top of stack
   146                          ;    pop hl              ; Loads y1x1 into hl
   147                          ;    pop de              ; Loads y2x2 into de
   148                          ;    pop bc              ; Loads colour into c
   149                          ;    push ix             ; Restores stack ret
   150                          
   151                          ; push and pop of ix/iy is 14t, on AFHLDEBC its 10, so, use BC for a small saving, and pop to iy for the colour,
   152                          ; this will save a LD IYL, C later, as IYL will be set from the pop, it's a small saving, but it adds up
   153                          ; also, avoid using IX (so allen said, so switch to iy)
   154                          ; This can use the original PlotPixel8K
   155                          ;    pop bc
   156                          ;    pop hl
   157                          ;    pop de
   158                          ;    pop iy
   159                          ;    push bc
   160                          
   161                          ; or, even better, set the colour in AF, and store that in the PlotPixel8KCol
   162  006a  c1                    pop bc
   163  006b  e1                    pop hl
   164  006c  d1                    pop de
   165  006d  fde1                  pop iy          ; sadly, you cannot use POP AF, as the colour is in the Flag register, so we need to use iy for the colour
   166  006f  c5                    push bc
   167                          
   168                          drawL2:
   169                          ;=========================================================================
   170                          ;   HL = Y1X1, DE = Y2X2, IXL = colour
   171                          ;=========================================================================
   172                          ;    ld ixl, c           ; Frees c (colour) for use by storing it into ixl (IYL is the colour register) - old version
   173                              ; the other option has iyl preloaded with the colour, so we can use it directly
   174                          
   175                              ; these 2 lines are only is you are using the PlotPixel8KCol, which is a self-modifying code that stores the colour in a variable
   176  0070  fd7d                  ld a,iyl        ; shame you cannot pop AF, so we could do this directly.
   177  0072  326800                ld (plotPixel8KColour + 1), a ; Store the colour in the plotPixel8KColour variable, so we can use it later
   178                          
   179  0075  7a                    ld a, d             ; Loads y2 into a. We'll see if we need to swap coords to draw downwards
   180  0076  bc                    cp h                ; Compares y1 with y2
   181  0077  3001                  jr nc, draw_line_1  ; No need to swap the coords, jump
   182  0079  eb                    ex de, hl           ; Swapped coordinates to ensure y2 > y1, so we draw downwards
   183                          draw_line_1:
   184  007a  7a                    ld a, d             ; Loads y2 into a
   185  007b  94                    sub h               ; y2 - y1
   186  007c  47                    ld b, a             ; b becomes deltay
   187  007d  7b                    ld a, e             ; Loads x2 into a
   188  007e  95                    sub l               ; x2 - x1, a now contains deltax
   189  007f  3805                  jr c, draw_line_x1  ; If carry is set (x2 - x1 is negative) we are drawing right to left
   190  0081  4f                    ld c, a             ; c becomes deltax
   191  0082  3e2c                  ld a, 0x2C          ; Replaces original code above to increase x1 as we're drawing left to right. 0x2C is inc l, and we modify the code to have this
   192  0084  1805                  jr draw_line_x2     ; Skips next part of the code
   193                          draw_line_x1:
   194  0086  ed44                  neg                 ; deltax in a is negative, make it positive
   195  0088  4f                    ld c, a             ; c becomes deltax
   196  0089  3e2d                  ld a, 0x2D          ; Replaces original code above to decrease x1 as we're drawing right to left. Self-modifying, puts dec l into the code
   197                          draw_line_x2:
   198  008b  32b100                ld (draw_line_q1_m2), a ; a contains either inc l or dec l, and modifies the code accordingly
   199  008e  32c800                ld (draw_line_q2_m2), a ; Same as above for verticalish lines
   200  0091  78                    ld a, b             ; We'll check if deltay (b) and deltax (ixl) are 0
   201  0092  b1                    or c                ; Checking...
   202                          ;    jp z, PlotPixel8K
   203  0093  ca5800                jp z, PlotPixel8KCol
   204                          ;    jr z, draw_line_p   ; There's no line to speak of, let's just draw a point and be done with it - just jump to PlotPixel8K/Col and save a jump
   205                              ; STATUS: b = deltay | c = deltax | d is free
   206                          
   207                          draw_line_q:            ; Find out what kind of diagonal we're dealing with, if horizontalish or verticalish
   208  0096  78                    ld a, b             ; Loads deltay into a
   209  0097  b9                    cp c                ; Compares with deltax
   210  0098  301d                  jr nc, draw_line_q2 ; If no cary, line is verticalish (or perfectly diagonal)
   211                          
   212                          draw_line_q1:
   213  009a  79                    ld a, c             ; a becomes deltax
   214  009b  32ae00                ld (draw_line_q1_m1 + 1), a ; Self-modifying code: loads deltax onto the value of the opcode, in this case the loop
   215  009e  48                    ld c, b             ; c becomes deltay
   216  009f  47                    ld b, a             ; b becomes deltax for the loop counter
   217  00a0  58                    ld e, b             ; e becomes deltax temporarily...
   218  00a1  cb3b                  srl e               ; now e = deltax / 2 -- aka Bresenham's error
   219                          
   220                          ; loop uses D as temp, HL BC E
   221                          draw_line_q1_l:
   222  00a3  54                    ld d, h             ; OPTIMISE? Backs up h into d
   223                          ;    call PlotPixel8K    ; PlotPixel8K destroys h, so we need to preserve it
   224  00a4  cd5800                call PlotPixel8KCol    ; PlotPixel8K destroys h, so we need to preserve it
   225  00a7  62                    ld h, d             ; OPTIMISE? Restores h from d
   226  00a8  7b                    ld a, e             ; Loads Bresenham's error into a
   227  00a9  91                    sub c               ; error - deltay
   228  00aa  5f                    ld e, a             ; Stores new error value into e
   229  00ab  3004                  jr nc, draw_line_q1_m2  ; If there's no cary, jump
   230                          draw_line_q1_m1:
   231  00ad  c600                  add a, 0            ; This 0 here will be modified by the self-modifying code above e = e + deltax
   232  00af  5f                    ld e, a             ; Stores new error e = e + deltax back into e
   233  00b0  24                    inc h               ; Increases line slope by adding to y1
   234                          draw_line_q1_m2:        ; This either increases or decreases l by the self modified code that targeted this
   235  00b1  2c                    inc l               ; Self-modified code: It will be either inc l or dec l depending on direction of horizontal drawing
   236                          draw_line_q1_s:         ; Tests to loop and keep drawing line
   237  00b2  10ef                  djnz draw_line_q1_l ; Loops until line is drawn and zero flag set
   238                          ;draw_line_p:            ; Plots the final pixel of the line if we are done with the loop above
   239                          ;    jp PlotPixel8K    ; While PlotPixel8K destroys h, this is the last pixel, thus we don't care
   240  00b4  c35800                jp PlotPixel8KCol    ; While PlotPixel8K destroys h, this is the last pixel, thus we don't care
   241                          ;    ret                ; if we use a jp, we return from that anyway, so no need for ret here
   242                          
   243                          
   244                          draw_line_q2:           ; Here the line is verticalish or perfectly diagonal
   245  00b7  32c700                ld (draw_line_q2_m1 + 1), a ; Self-modifies the code to store deltay in the loop
   246  00ba  58                    ld e, b             ; e = deltay
   247  00bb  cb3b                  srl e               ; e = deltay / 2 (Bressenham's error)
   248                          
   249                          ; loop
   250                          draw_line_q2_l:         ; The main drawline loop for this case
   251  00bd  54                    ld d, h             ; OPTIMISE? Backs up h into d
   252                          ;    call PlotPixel8K    ; PlotPixel8K destroys h, so we need to preserve it
   253  00be  cd5800                call PlotPixel8KCol    ; PlotPixel8K destroys h, so we need to preserve it
   254  00c1  62                    ld h, d             ; OPTIMISE? Restores h from d
   255                          ;   or d                ; Or the value (not sure why this is here)
   256  00c2  7b                    ld a, e             ; Adds deltax to the error
   257  00c3  91                    sub c               ; As above
   258  00c4  3003                  jr nc, draw_line_q2_s   ; If we don't get a carry, skip the next part
   259                          draw_line_q2_m1:
   260  00c6  c600                  add a, 0            ; This is a target of self-modified code: e = e + deltax
   261                          draw_line_q2_m2:
   262  00c8  2c                    inc l               ; Self-modified code: It will be either inc l or dec l depending on direction of horizontal drawing
   263                          draw_line_q2_s:
   264  00c9  5f                    ld e, a             ; Restores the error value back in
   265  00ca  24                    inc h               ; Increases y1
   266  00cb  10f0                  djnz draw_line_q2_l ; While zero flag not set, loop back to main loop
   267                          ;    jp PlotPixel8K    ; While PlotPixel8K destroys h, this is the last pixel, thus we don't care
   268  00cd  c35800                jp PlotPixel8KCol    ; While PlotPixel8K destroys h, this is the last pixel, thus we don't care
   269                          ;    jr draw_line_p      ; If zero flag is finally set, jump to draw our last pixel of the line and... Done
   270                          
